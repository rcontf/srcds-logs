import { Buffer } from "node:buffer";
import { EventEmitter } from "node:events";
import { type Socket, createSocket, type RemoteInfo } from "node:dgram";
import { parsePacket } from "./parser";
import { EventData } from "./types";

/**
 * The socket options for the UDP socket
 */
export interface LogReceiverOptions {
  /**
   * The address to listen on
   * 
   * @default "0.0.0.0"
   */
  address?: string;

  /**
   * The port to use
   * 
   * @default 9871
   */
  port?: number;

  /**
   * The abort signal to use
   *
   * When calling {@link AbortSignal.abort}, it will automatically close the underlying socket
   */
  signal?: AbortSignal;
}

/**
 * An event emitter that will emit a message event when a valid UDP log is created on the server
 *
 * When a log is sent, there will be a `message` event published that you can extract the data from. This is a valid payload. It is important to check the IP or password of the content to ensure it came from a trusted source
 *
 * You can listen on socket events such as `error` and `close` by listening to those events. All default events of the {@link Socket} will be forwarded. If you need to close the socket at any time, provide an {@link AbortSignal}. Aborting will automatically call {@link Socket.close} for you on the socket and emits a `close` event
 *
 * @example Simple receiver that logs to console every message
 * ```ts
 * import { LogReceiver} from "@c43721/srcds-log-receiver";
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * receiver.on("event", (message) => console.log(message));
 * ```
 *
 * On every log generated by the srcds server, it will log that message out to console
 *
 * @example Passing in an abort controller to close the socket
 * ```ts
 * import { LogReceiver} from "@c43721/srcds-log-receiver";
 *
 * const controller = new AbortController();
 * const { signal } = controller;
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * receiver.on("event", (message) => console.log(message));
 * receiver.on("close", () => console.log("Closed the socket"));
 *
 * controller.abort();
 * ```
 *
 * While not required, there may be times where you have short-lived receivers. Since each instance creates a socket, closing those sockets becomes a problem. Abort controllers help with that by providing a way to explicitly close the resources for you
 *
 */
export class LogReceiver extends EventEmitter {
  #socket: Socket;

  /**
   * Creates a new receiver
   * @param options The log reciever options to use
   */
  constructor(
    options: LogReceiverOptions = {
      address: "0.0.0.0",
      port: 9871,
    }
  ) {
    const { address, port, signal } = options;

    super();

    this.#socket = createSocket({
      type: "udp4",
      signal,
    });

    this.#socket.bind(port, address);

    this.#socket.on("close", () => this.emit("close"));
    this.#socket.on("connect", () => this.emit("connect"));
    this.#socket.on("error", (error) => this.emit("error", error));
    this.#socket.on("listening", () => this.emit("listening"));
    this.#socket.on("message", (buffer, serverInfo) => this.#handleMessage(buffer, serverInfo));
  }

  #handleMessage(buffer: Buffer, serverInfo: RemoteInfo) {
    const response = parsePacket(buffer);

    if (response == null) {
      return;
    }

    const eventData = { ...response, socket: serverInfo } as EventData;

    this.emit("event", eventData);
  }
}
