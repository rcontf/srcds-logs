/// <reference types="@types/node" />
import { createSocket, type RemoteInfo, type Socket } from "node:dgram";
import { parsePacket } from "./parser.ts";
import type { EventData } from "./types.ts";

/**
 * The socket options for the UDP socket
 */
export interface LogReceiverOptions {
  /**
   * The address to listen on
   *
   * @default "0.0.0.0"
   */
  address?: string;

  /**
   * The port to use
   *
   * @default 9871
   */
  port?: number;

  /**
   * The abort signal to use
   *
   * When calling {@linkcode AbortSignal.abort}, it will automatically close the underlying socket
   */
  signal?: AbortSignal;
}

/**
 * An event emitter that will emit a message event when a valid UDP log is created on the server
 *
 * When a log is sent, there will be a `message` event published that you can extract the data from. This is a valid payload. It is important to check the IP or password of the content to ensure it came from a trusted source
 *
 * You can listen on socket events such as `error` and `close` by listening to those events. All default events of the {@link Socket} will be forwarded. If you need to close the socket at any time, provide an {@link AbortSignal}. Aborting will automatically call {@link Socket.close} for you on the socket and emits a `close` event
 *
 * @example Simple receiver that logs to console every message
 * ```ts
 * import { LogReceiver } from "@c43721/srcds-log-receiver";
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * for await (const message of receiver) {
 *   console.log(message)
 * }
 * ```
 *
 * On every log generated by the srcds server, it will log that message out to console
 *
 * @example Passing in an abort controller to close the socket
 * ```ts
 * import { LogReceiver } from "@c43721/srcds-log-receiver";
 *
 * const controller = new AbortController();
 * const { signal } = controller;
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * // timeout after 5 seconds
 * setTimeout(() => {
 *   console.log("Aborting");
 *   controller.abort();
 * }, 5000);
 *
 * for await (const message of receiver) {
 *   console.log(message)
 * }
 *
 * ```
 *
 * While not required, there may be times where you have short-lived receivers. Since each instance creates a socket, closing those sockets becomes a problem. Abort controllers help with that by providing a way to explicitly close the resources for you
 *
 * @example Using the password and IP to verify the source of the data
 * ```ts
 * import { LogReceiver } from "@c43721/srcds-log-receiver";
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * for await (const data of receiver) {
 *   if (data.password === null) {
 *     console.log("Bad password");
 *   } else if (data.password === "mysuperdupersecret") {
 *     console.log(data);
 *   }
 * }
 *
 * ```
 *
 * For security reasons, you should always use a log secret to prevent evaluation of potentially malicious messages. Do this by looking at the password field. In order to set up the log secret, you can use the `sv_logsecret` command
 */
export class LogReceiver implements Disposable {
  #socket: Socket;
  #stream: ReadableStream<EventData>;

  /**
   * Creates a new receiver
   * @param options The log reciever options to use
   */
  constructor(
    options: LogReceiverOptions = {
      address: "0.0.0.0",
      port: 9871,
    },
  ) {
    const { address, port, signal } = options;

    this.#socket = createSocket({
      type: "udp4",
      signal,
    });

    signal?.addEventListener("abort", () => this.dispose(), { once: true });

    this.#socket.bind(port, address);

    this.#stream = new ReadableStream<EventData>({
      start: (controller) => {
        this.#socket.on("message", (buffer: Uint8Array, serverInfo: RemoteInfo) => {
          const data = this.#handleMessage(buffer, serverInfo);

          if (data !== null) {
            controller.enqueue(data);
          }

          signal?.addEventListener("abort", () => controller.close(), { once: true });
        });

        this.#socket.on("close", () => controller.close());
        this.#socket.on("error", () => controller.error());
      },
    });
  }

  /**
   * Destroys the socket
   */
  [Symbol.dispose]() {
    this.dispose();
  }

  dispose() {
    this.#socket.unref();
    this.#socket.close();
  }

  /**
   * Iterates over all the messages as they come in from the server
   */
  [Symbol.asyncIterator](): AsyncIterator<EventData> {
    return this.#stream.values();
  }
  
  #handleMessage(buffer: Uint8Array, serverInfo: RemoteInfo) {
    const response = parsePacket(buffer);

    if (response === null) {
      return null;
    }

    const eventData = { ...response, socket: serverInfo } satisfies EventData;

    return eventData;
  }
}
