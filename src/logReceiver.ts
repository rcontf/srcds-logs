/// <reference types="@types/node" />
import { EventEmitter } from "node:events";
import { createSocket, type RemoteInfo, type Socket } from "node:dgram";
import { parsePacket } from "./parser.ts";
import type { EventData, MessageEvents, TypedEventEmitter } from "./types.ts";

/**
 * The socket options for the UDP socket
 */
export interface LogReceiverOptions {
  /**
   * The address to listen on
   *
   * @default "0.0.0.0"
   */
  address?: string;

  /**
   * The port to use
   *
   * @default 9871
   */
  port?: number;

  /**
   * The abort signal to use
   *
   * When calling {@link AbortSignal.abort}, it will automatically close the underlying socket
   */
  signal?: AbortSignal;
}

/**
 * An event emitter that will emit a message event when a valid UDP log is created on the server
 *
 * When a log is sent, there will be a `message` event published that you can extract the data from. This is a valid payload. It is important to check the IP or password of the content to ensure it came from a trusted source
 *
 * You can listen on socket events such as `error` and `close` by listening to those events. All default events of the {@link Socket} will be forwarded. If you need to close the socket at any time, provide an {@link AbortSignal}. Aborting will automatically call {@link Socket.close} for you on the socket and emits a `close` event
 *
 * @example Simple receiver that logs to console every message
 * ```ts
 * import { LogReceiver} from "@c43721/srcds-log-receiver";
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * receiver.on("event", (message) => console.log(message));
 * ```
 *
 * On every log generated by the srcds server, it will log that message out to console
 *
 * @example Passing in an abort controller to close the socket
 * ```ts
 * import { LogReceiver} from "@c43721/srcds-log-receiver";
 *
 * const controller = new AbortController();
 * const { signal } = controller;
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * receiver.on("event", (message) => console.log(message));
 * receiver.on("close", () => console.log("Closed the socket"));
 *
 * controller.abort();
 * ```
 *
 * While not required, there may be times where you have short-lived receivers. Since each instance creates a socket, closing those sockets becomes a problem. Abort controllers help with that by providing a way to explicitly close the resources for you
 *
 * @example Using the password and IP to verify the source of the data
 * ```ts
 * import { LogReceiver} from "@c43721/srcds-log-receiver";
 *
 * const receiver = new LogReceiver({
 *   address: "0.0.0.0",
 *   port: 9871,
 * });
 *
 * receiver.on("event", (message) => {
 *    if (message.password === null) {
 *      return;
 *    }
 *
 *    if (message.password === "mysuperdupersecretlogpassword") {
 *      await doSomethingWithTheMessage(message);
 *    }
 * });
 *
 * ```
 *
 * For security reasons, you should always use a log secret to prevent evaluation of potentially malicious messages. Do this by looking at the password field. In order to set up the log secret, you can use the `sv_logsecret` command
 */
export class LogReceiver extends EventEmitter implements TypedEventEmitter<MessageEvents>, Disposable {
  #socket: Socket;

  /**
   * Creates a new receiver
   * @param options The log reciever options to use
   */
  constructor(
    options: LogReceiverOptions = {
      address: "0.0.0.0",
      port: 9871,
    },
  ) {
    const { address, port, signal } = options;

    super();

    this.#socket = createSocket({
      type: "udp4",
      signal,
    });

    this.#socket.bind(port, address);

    this.#socket.on("error", (error) => this.emit("error", error));
    this.#socket.on("message", (buffer, serverInfo) => this.#handleMessage(buffer, serverInfo));
  }

  /**
   * Destroys the socket
   */
  [Symbol.dispose]() {
    this.#socket.close();
  }

  #handleMessage(buffer: Uint8Array, serverInfo: RemoteInfo) {
    const response = parsePacket(buffer);

    if (response == null) {
      return;
    }

    const eventData = { ...response, socket: serverInfo } satisfies EventData;

    this.emit("event", eventData);
  }
}
